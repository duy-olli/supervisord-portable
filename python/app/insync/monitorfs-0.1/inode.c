/*
 * Copyright (c) 1997-2007 Erez Zadok <ezk@cs.stonybrook.edu>
 * Copyright (c) 2001-2007 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from
 * ftp://ftp.filesystems.org/pub/fistgen/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 * File: fistgen/templates/Linux-2.6/inode.c
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_monitorfs.h"
#endif /* FISTGEN */
#include "fist.h"
#include "monitorfs.h"

//XXX: mickg: pagemap.h cannot be included for some arcane reason, so this hack.
//#define PAGE_CACHE_SHIFT	PAGE_SHIFT
//#define PAGE_CACHE_SIZE		PAGE_SIZE
//#define PAGE_CACHE_MASK		PAGE_MASK

/*
 * Common dentry functions for inclusion in the VFS
 * or in other stackable file systems.  Some of these
 * functions were in linux/fs/ C (VFS) files.
 *
 */

/*
 * Locking the parent is needed to:
 *  - serialize directory operations
 *  - make sure the parent doesn't change from
 *    under us in the middle of an operation.
 *
 * NOTE! Right now we'd rather use a "struct inode"
 * for this, but as I expect things to move toward
 * using dentries instead for most things it is
 * probably better to start with the conceptually
 * better interface of relying on a path of dentries.
 */
static inline struct dentry *monitorfs_lock_parent(struct dentry *dentry) {
        struct dentry *dir = dget(dentry->d_parent);

        lock_inode(dir->d_inode);
        return dir;
}

static inline void unlock_dir(struct dentry *dir)
{
        unlock_inode(dir->d_inode);
        dput(dir);
}

STATIC int
monitorfs_create(inode_t *dir, struct dentry *dentry, int mode, struct nameidata *nd)
{
        int err;
        struct dentry *lower_dentry;
	struct vfsmount *lower_mount;
        struct dentry *lower_dir_dentry;
	FIST_ND_DECLARATIONS;

        print_entry_location();
        lower_dentry = monitorfs_lower_dentry(dentry);
        BUG_ON(!lower_dentry);
        fist_checkinode(dir, "monitorfs_create");
	lower_mount = DENTRY_TO_LVFSMNT(dentry);

        lower_dir_dentry = monitorfs_lock_parent(lower_dentry);
        err = PTR_ERR(lower_dir_dentry);
        if (IS_ERR(lower_dir_dentry))
                goto out;

	FIST_ND_SAVE_ARGS(dentry, lower_dentry, lower_mount);
        err = vfs_create(lower_dir_dentry->d_inode, lower_dentry, mode, nd);
	FIST_ND_RESTORE_ARGS;
        /* XXX this could potentially return a negative lower_dentry! */
        if (err)
                goto out_lock;

        err = monitorfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
        if (err)
                goto out_lock;

        fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);

		monitorfs_log_operation(MONITORFS_OPS_CREATE, dentry, NULL, NULL);

out_lock:
        unlock_dir(lower_dir_dentry);
out:
        fist_checkinode(dir, "post monitorfs_create");
        print_exit_status(err);
        return err;
}


STATIC struct dentry *
monitorfs_lookup(inode_t *dir,
	      struct dentry *dentry,
	      struct nameidata* nd_unused_in_this_fxn /* XXX: fix code if ever used */ )
{
        int err = 0;
        struct dentry *lower_dir_dentry;
        struct dentry *lower_dentry = NULL;
        struct vfsmount *lower_mount;
        const char *name;
        vnode_t *this_vnode;
        struct dentry *this_dir;
        unsigned int namelen;

        print_entry_location();
        lower_dir_dentry = monitorfs_lower_dentry(dentry->d_parent);	/* CPW: Moved below print_entry_location */
        name = dentry->d_name.name;
        namelen = dentry->d_name.len;
        fist_checkinode(dir, "monitorfs_lookup");

        this_vnode = dir;
        this_dir = lower_dir_dentry;

        fist_print_dentry("monitorfs_lookup IN", dentry);
        fist_print_dentry("monitorfs_lookup: dentry->d_parent IN", dentry->d_parent);
        fist_print_dentry("monitorfs_lookup: lower_dir_dentry IN", lower_dir_dentry);
        fist_print_inode("monitorfs_lookup: dir IN", dir);

        if (lower_dir_dentry->d_inode)
                fist_print_inode("monitorfs_lookup: lower_dir_dentry->d_inode",
                                 lower_dir_dentry->d_inode);

        /* must initialize dentry operations */
        dentry->d_op = &monitorfs_dops;

        ;

        /* increase refcount of base dentry (lookup_one[_len] will decrement) */
        // THIS IS RIGHT! (don't "fix" it)
        // NO THIS IS WRONG IN 2.3.99-pre6. lookup_one[_len] will NOT decrement
        // dget(lower_dir_dentry);

        lock_inode(lower_dir_dentry->d_inode);
        /* will allocate a new lower dentry if needed */
        lower_dentry = lookup_one_len(name, lower_dir_dentry, namelen);
        unlock_inode(lower_dir_dentry->d_inode);
	/* XXX: This needs to change to something intelligent with follow_down. */
	lower_mount = mntget(DENTRY_TO_LVFSMNT(dentry->d_parent));

        if (IS_ERR(lower_dentry)) {
                /*
                 * this produces an unusual dentry: one that has neither an
                 * inode, nor a private structure attached to it. All cleanup
                 * methods (d_delete, d_release, etc) must be prepared to deal
                 * with such dentries. Ion 09/29/2001
                 */
                printk("ERR from lower_dentry!!!\n");
                err = PTR_ERR(lower_dentry);
                goto out;
        }

        ;

        /* update parent directory's atime */
        fist_copy_attr_atime(dir, lower_dir_dentry->d_inode);
        /* link the upper and lower dentries */
        DENTRY_TO_PRIVATE_SM(dentry) = (struct monitorfs_dentry_info *) KMALLOC(sizeof(struct monitorfs_dentry_info), GFP_KERNEL);
        if (!DENTRY_TO_PRIVATE(dentry)) {
                err = -ENOMEM;
                goto out_dput;
        }
        DENTRY_TO_PRIVATE(dentry)->wdi_dentry = lower_dentry;
	DENTRY_TO_PRIVATE(dentry)->wdi_mnt = lower_mount;


        /* lookup is special: it needs to handle negative dentries */
        if (!lower_dentry->d_inode) {
                d_add(dentry, NULL);
                fist_print_dentry("monitorfs_lookup OUT lower_dentry", lower_dentry);
                goto out;
        }

        fist_dprint(6, "lookup \"%s\" -> inode %lu\n", name, lower_dentry->d_inode->i_ino);
        err = monitorfs_interpose(lower_dentry, dentry, dir->i_sb, 1);
        if (err)
                goto out_free;

        fist_checkinode(dentry->d_inode, "monitorfs_lookup OUT: dentry->d_inode:");
        fist_checkinode(dir, "monitorfs_lookup OUT: dir");

        fist_print_dentry("monitorfs_lookup OUT lower_dentry", lower_dentry);
        fist_print_inode("monitorfs_lookup OUT lower_inode", lower_dentry->d_inode);


        /* All is well */
        goto out;

out_free:
        d_drop(dentry);		/* so that our bad dentry will get destroyed */


        KFREE(DENTRY_TO_PRIVATE(dentry));
        DENTRY_TO_PRIVATE_SM(dentry) = NULL;	/* be safe */

out_dput:
        if (lower_dentry)
                dput(lower_dentry);

out:
        fist_print_dentry("monitorfs_lookup OUT", dentry);
        print_exit_status(err);
        return ERR_PTR(err);
}


STATIC int
monitorfs_link(struct dentry *old_dentry, inode_t *dir, struct dentry *new_dentry)
{
        int err;
        struct dentry *lower_old_dentry;
        struct dentry *lower_new_dentry;
        struct dentry *lower_dir_dentry;

        print_entry_location();
        lower_old_dentry = monitorfs_lower_dentry(old_dentry);	/* CPW: Moved below print_entry_location */
        lower_new_dentry = monitorfs_lower_dentry(new_dentry);

        fist_checkinode(dir, "monitorfs_link-dir");
        fist_checkinode(old_dentry->d_inode, "monitorfs_link-oldinode");

        dget(lower_old_dentry);
        dget(lower_new_dentry);
        lower_dir_dentry = monitorfs_lock_parent(lower_new_dentry);


        err = VFS_LINK(lower_old_dentry,
                       lower_dir_dentry->d_inode,
                       lower_new_dentry);
        if (err || !lower_new_dentry->d_inode)
                goto out_lock;

        err = monitorfs_interpose(lower_new_dentry, new_dentry, dir->i_sb, 0);
        if (err)
                goto out_lock;

        fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);
        /* propagate number of hard-links */
        old_dentry->d_inode->i_nlink = INODE_TO_LOWER(old_dentry->d_inode)->i_nlink;
		
		monitorfs_log_operation(MONITORFS_OPS_CREATE, new_dentry, NULL, NULL);
out_lock:
        unlock_dir(lower_dir_dentry);
        dput(lower_new_dentry);
        dput(lower_old_dentry);
        if (!new_dentry->d_inode)
                d_drop(new_dentry);

        print_exit_status(err);
        return err;
}


STATIC int
monitorfs_unlink(inode_t *dir, struct dentry *dentry)
{
        int err = 0;
        inode_t *lower_dir;
        struct dentry *lower_dentry;
        struct dentry *lower_dir_dentry;

        print_entry_location();

        lower_dir = INODE_TO_LOWER(dir); /* CPW: Moved below print_entry_location */
        lower_dentry = monitorfs_lower_dentry(dentry);

        BUG_ON(!lower_dentry);
        fist_checkinode(dir, "monitorfs_unlink-dir");

        dget(dentry);
        lower_dir_dentry = monitorfs_lock_parent(lower_dentry);


        /* avoid destroying the lower inode if the file is in use */
        dget(lower_dentry);
        err = VFS_UNLINK(lower_dir, lower_dentry);
        dput(lower_dentry);

        if (!err)			  /* vfs_unlink does that */
                d_delete(lower_dentry);

		monitorfs_log_operation(MONITORFS_OPS_DELETE, dentry, NULL, NULL);
		
out_lock:
        fist_copy_attr_times(dir, lower_dir);
        /* propagate number of hard-links */
        dentry->d_inode->i_nlink = INODE_TO_LOWER(dentry->d_inode)->i_nlink;
    	fist_copy_attr_ctime(dentry->d_inode, dir);

        unlock_dir(lower_dir_dentry);

        /*
         * call d_drop so the system "forgets" about us
         */
        if (!err) {
                d_drop(dentry);
        }

        dput(dentry);

        fist_checkinode(dir, "post monitorfs_unlink-dir");
        print_exit_status(err);
        return err;
}


STATIC int
monitorfs_symlink(inode_t *dir, struct dentry *dentry, const char *symname)
{
        int err;
        struct dentry *lower_dentry;
        struct dentry *lower_dir_dentry;
        umode_t	mode;

        print_entry_location();
        lower_dentry = monitorfs_lower_dentry(dentry);	/* CPW: Moved below print_entry_location */
        fist_checkinode(dir, "monitorfs_symlink-dir");

        dget(lower_dentry);
        lower_dir_dentry = monitorfs_lock_parent(lower_dentry);

        mode = S_IALLUGO;


        err = VFS_SYMLINK(lower_dir_dentry->d_inode, lower_dentry, symname, mode);


        if (err || !lower_dentry->d_inode)
                goto out_lock;
        err = monitorfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
        if (err)
                goto out_lock;

        fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);
        fist_checkinode(dir, "post monitorfs_symlink-dir");

		monitorfs_log_operation(MONITORFS_OPS_CREATE, dentry, NULL, NULL);	
		
out_lock:
        unlock_dir(lower_dir_dentry);
        dput(lower_dentry);
        if (!dentry->d_inode)
                d_drop(dentry);

        print_exit_status(err);
        return err;
}


STATIC int
monitorfs_mkdir(inode_t *dir, struct dentry *dentry, int mode)
{
        int err;
        struct dentry *lower_dentry;
        struct dentry *lower_dir_dentry;

        print_entry_location();
        lower_dentry = monitorfs_lower_dentry(dentry);	/* CPW: Moved below print_entry_location */
        fist_checkinode(dir, "monitorfs_mkdir-dir");

        lower_dir_dentry = monitorfs_lock_parent(lower_dentry);

        err = VFS_MKDIR(lower_dir_dentry->d_inode,
                        lower_dentry,
                        mode);
        if (err || !lower_dentry->d_inode)
                goto out;

        err = monitorfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
        if (err)
                goto out;

        fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);
        /* update number of links on parent directory */
        dir->i_nlink = lower_dir_dentry->d_inode->i_nlink;

        fist_checkinode(dir, "post monitorfs_mkdir-dir");
		monitorfs_log_operation(MONITORFS_OPS_CREATE, dentry, NULL, NULL);
out:
        unlock_dir(lower_dir_dentry);
        if (!dentry->d_inode)
                d_drop(dentry);

        print_exit_status(err);
        return err;
}


STATIC int
monitorfs_rmdir(inode_t *dir, struct dentry *dentry)
{
        int err = 0;
        struct dentry *lower_dentry;
        struct dentry *lower_dir_dentry;

        print_entry_location();
        lower_dentry = monitorfs_lower_dentry(dentry);	/* CPW: Moved below print_entry_location */
        fist_checkinode(dir, "monitorfs_rmdir-dir");

        dget(dentry);
        lower_dir_dentry = monitorfs_lock_parent(lower_dentry);

        /* avoid destroying the lower inode if the file is in use */
        dget(lower_dentry);
        err = VFS_RMDIR(lower_dir_dentry->d_inode, lower_dentry);
        dput(lower_dentry);

        if (!err)			  /* vfs_rmdir does that */
                d_delete(lower_dentry);
				
		monitorfs_log_operation(MONITORFS_OPS_DELETE, dentry, NULL, NULL);
out_lock:
        fist_copy_attr_times(dir, lower_dir_dentry->d_inode);
        /* copy the nlink count for our dentry and our parent's dentry */
        dir->i_nlink =  lower_dir_dentry->d_inode->i_nlink;

        unlock_dir(lower_dir_dentry);

        /*
         * call d_drop so the system "forgets" about us
         */
        if (!err)
                d_drop(dentry);

        dput(dentry);

        print_exit_status(err);
        return err;
}


STATIC int
monitorfs_mknod(inode_t *dir, struct dentry *dentry, int mode, dev_t dev)
{
        int err;
        struct dentry *lower_dentry;
        struct dentry *lower_dir_dentry;

        print_entry_location();
        lower_dentry = monitorfs_lower_dentry(dentry);	/* CPW: Moved below print_entry_location */
        fist_checkinode(dir, "monitorfs_mknod-dir");

        lower_dir_dentry = monitorfs_lock_parent(lower_dentry);

        err = VFS_MKNOD(lower_dir_dentry->d_inode,
                        lower_dentry,
                        mode,
                        dev);
        if (err || !lower_dentry->d_inode)
                goto out;

        err = monitorfs_interpose(lower_dentry, dentry, dir->i_sb, 0);
        if (err)
                goto out;
        fist_copy_attr_timesizes(dir, lower_dir_dentry->d_inode);
		
		monitorfs_log_operation(MONITORFS_OPS_CREATE, dentry, NULL, NULL);
out:
        unlock_dir(lower_dir_dentry);
        if (!dentry->d_inode)
                d_drop(dentry);

        fist_checkinode(dir, "post monitorfs_mknod-dir");
        print_exit_status(err);
        return err;
}


STATIC int
monitorfs_rename(inode_t *old_dir, struct dentry *old_dentry,
              inode_t *new_dir, struct dentry *new_dentry)
{
        int err;
        struct dentry *lower_old_dentry;
        struct dentry *lower_new_dentry;
        struct dentry *lower_old_dir_dentry;
        struct dentry *lower_new_dir_dentry;

        print_entry_location();

        lower_old_dentry = monitorfs_lower_dentry(old_dentry);/* CPW: Moved below print_entry_location */
        lower_new_dentry = monitorfs_lower_dentry(new_dentry);

        fist_checkinode(old_dir, "monitorfs_rename-old_dir");
        fist_checkinode(new_dir, "monitorfs_rename-new_dir");

        dget(lower_old_dentry);
        dget(lower_new_dentry);
        lower_old_dir_dentry = dget_parent(lower_old_dentry);
        lower_new_dir_dentry = dget_parent(lower_new_dentry);
        lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);


        err = VFS_RENAME(lower_old_dir_dentry->d_inode, lower_old_dentry,
                         lower_new_dir_dentry->d_inode, lower_new_dentry);
        if (err)
                goto out_lock;

        fist_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode);
        if (new_dir != old_dir)
                fist_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode);

		monitorfs_log_operation(MONITORFS_OPS_RENAME, old_dentry, new_dentry, NULL);
out_lock:
        // unlock_rename will dput the new/old parent dentries whose refcnts
        // were incremented via dget_parent above.
        dput(lower_new_dentry);
        dput(lower_old_dentry);
        unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);

        fist_checkinode(new_dir, "post monitorfs_rename-new_dir");
        print_exit_status(err);
        return err;
}


STATIC int
monitorfs_readlink(struct dentry *dentry, char *buf, int bufsiz)
{
        int err;
        struct dentry *lower_dentry;

        print_entry_location();
        lower_dentry = monitorfs_lower_dentry(dentry);/* CPW: Moved below print_entry_location */
        fist_print_dentry("monitorfs_readlink IN", dentry);

        if (!lower_dentry->d_inode->i_op ||
             !lower_dentry->d_inode->i_op->readlink) {
                err = -EINVAL;
                goto out;
        }

        err = lower_dentry->d_inode->i_op->readlink(lower_dentry,
                                                    buf,
                                                    bufsiz);
        if (err > 0)
                fist_copy_attr_atime(dentry->d_inode, lower_dentry->d_inode);

out:
        print_exit_status(err);
        return err;
}

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
STATIC int
monitorfs_follow_link(struct dentry *dentry, struct nameidata *nd)
#else /* 2.6.13 or newer */
STATIC void *
monitorfs_follow_link(struct dentry *dentry, struct nameidata *nd)
#endif /* 2.6.13 or newer */
{
        char *buf;
        int len = PAGE_SIZE, err;
        mm_segment_t old_fs;
	struct dentry *lower_dentry;

        print_entry_location();
        //    fist_print_dentry("monitorfs_follow_link dentry IN", dentry);

	/* buf is allocated here, and freed when VFS calls our put_link method */
	err = -ENOMEM;
        buf = KMALLOC(len, GFP_KERNEL);
        if (!buf)
                goto out;

        old_fs = get_fs();
        set_fs(KERNEL_DS);
        err = dentry->d_inode->i_op->readlink(dentry, buf, len);
        set_fs(old_fs);
        if (err < 0)
                goto out_free;

        buf[err] = 0;	// terminate the buffer -- XXX still needed?
	err = 0;
	nd_set_link(nd,buf);
	goto out;

out_free:
	KFREE(buf);
out:
#if 0
        if (err < 0) {
                dput(nd->dentry);
                printk("EZK follow_link() mnt_cnt %d\n", 
                        (int) atomic_read(&nd->mnt->mnt_count));
                mntput(nd->mnt);
        }
#endif

        print_exit_status(err);
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
        return err;
#else /* 2.6.13 or newer */
        return ERR_PTR(err);
#endif /* 2.6.13 or newer */
}

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
void
monitorfs_put_link(struct dentry *dentry, struct nameidata *nd)
#else /* 2.6.13 or newer */
void
monitorfs_put_link(struct dentry *dentry, struct nameidata *nd, void* unused)
#endif /* 2.6.13 or newer */
{
        print_entry_location();

        KFREE(nd_get_link(nd));

        print_exit_location();
}



/* We call only the lower-level permission so that file systems with ACLs
 * or more complex permission models work correctly.  This results in
 * O(n^2) calls to permission with n stacked file systems, because each
 * vfs_foo function first calls permission for the top layer, which in
 * turn makes n calls, then calls vfs_foo on the next layer, which will
 * make n calls, etc.
 *
 * An alternative would be to punt permission checking entirely to the
 * lower-level file system, but then we would need to check that we aren't
 * performing any operations without appropriate permissions checking.
 */
#if defined HAVE_3_ARG_PERMISSION
STATIC int
monitorfs_permission(inode_t *inode, int mask, struct nameidata* nd)
{
        inode_t *lower_inode;
        int err;
	struct dentry *lower_dentry;
	struct vfsmount *lower_mount;
	FIST_ND_DECLARATIONS;

        print_entry_location();
        lower_inode = INODE_TO_LOWER(inode);

	if(nd)
	{
	    BUG_ON(!NAMEIDATA_TO_DENTRY(nd)); /* needed to find lower_dentry */
	    lower_dentry = monitorfs_lower_dentry(NAMEIDATA_TO_DENTRY(nd));
	    lower_mount = DENTRY_TO_LVFSMNT(NAMEIDATA_TO_DENTRY(nd));
	    BUG_ON(!SUPERBLOCK_TO_PRIVATE(NAMEIDATA_TO_DENTRY(nd)->d_sb)); /* needed in FIST_ND_SAVE_ARGS macro */
	    FIST_ND_SAVE_ARGS(NAMEIDATA_TO_DENTRY(nd), lower_dentry, lower_mount);
	}

	err = permission(lower_inode, mask, nd);

	if(nd)
	{
	    FIST_ND_RESTORE_ARGS;
	}

out:
        print_exit_status(err);
        return err;
}
#else /* !HAVE_3_ARG_PERMISSION */

/* Modern versions of Linux have dropped the nameidata argument from
 * inode_operations.permission, as well as removing the permission()
 * helper in favor of inode_permission().
 */

STATIC int
monitorfs_permission(inode_t *inode, int mask)
{
        inode_t *lower_inode;
        int err;

        print_entry_location();
        lower_inode = INODE_TO_LOWER(inode);
	err = inode_permission(lower_inode, mask);
        print_exit_status(err);
        return err;
}
#endif /* !HAVE_3_ARG_PERMISSION */

STATIC int
monitorfs_inode_revalidate(struct dentry *dentry)
{
        int err = 0;
        struct dentry *lower_dentry;
        inode_t *lower_inode;

        print_entry_location();
        lower_dentry = monitorfs_lower_dentry(dentry);
        lower_inode = lower_dentry->d_inode;
        //    fist_print_dentry("monitorfs_inode_revalidate IN", dentry);

        //Revalidate is GONE

        /* XXX:
           "->revalidate() is gone.  If your filesystem had it - provide ->getattr()
           and let it call whatever you had as ->revlidate() + (for symlinks that
           had ->revalidate()) add calls in ->follow_link()/->readlink()."
        */

        //    fist_print_dentry("monitorfs_inode_revalidate OUT", dentry);
        print_exit_status(err);
        return err;
}


STATIC int
monitorfs_setattr(struct dentry *dentry, struct iattr *ia)
{
        int err = 0;
        struct dentry *lower_dentry;
        inode_t *inode;
        inode_t *lower_inode;

        print_entry_location();
        lower_dentry = monitorfs_lower_dentry(dentry);
        inode = dentry->d_inode;
        lower_inode = INODE_TO_LOWER(inode);
        fist_checkinode(inode, "monitorfs_setattr");



        err = notify_change(lower_dentry, 
#ifdef HAVE_3_ARG_NOTIFY_CHANGE
                DENTRY_TO_LVFSMNT(dentry),
#endif
                ia);

#if defined(FIST_FILTER_DATA) || defined(FIST_FILTER_SCA)
out:
#endif /* FIST_FILTER_DATA || FIST_FILTER_SCA */
        /*
         * The lower file system might has changed the attributes, even if
         * notify_change above resulted in an error(!)  so we copy the
         * lower_inode's attributes (and a few more) to our inode.
         */
        fist_copy_attr_all(inode, lower_inode);

        fist_checkinode(inode, "post monitorfs_setattr");
        print_exit_status(err);
        return err;
}


#ifdef NOT_USED_YET
STATIC int
monitorfs_getattr(struct dentry *dentry, struct iattr *ia)
{
        return -ENOSYS;
}
#endif /* NOT_USED_YET */


/* This is lifted from fs/xattr.c */
static void *
xattr_alloc(size_t size, size_t limit)
{
        void *ptr;

        if (size > limit)
                return ERR_PTR(-E2BIG);

        if (!size)		  /* size request, no buffer is needed */
                return NULL;
        else if (size <= PAGE_SIZE)
                ptr = KMALLOC((unsigned long) size, GFP_KERNEL);
        else
                ptr	= vmalloc((unsigned long) size);
        if (!ptr)
                return ERR_PTR(-ENOMEM);
        return ptr;
}

static void
xattr_free(void *ptr, size_t size)
{
        if (!size)		  /* size request, no buffer was needed */
                return;
        else if (size <= PAGE_SIZE)
                KFREE(ptr);
        else
                vfree(ptr);
}

/*
 * BKL held by caller.
 * dentry->d_inode->i_{sem,mutex} down
 */
STATIC ssize_t
monitorfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)
{
        struct dentry *lower_dentry = NULL;
        int err = -ENOTSUPP;
        /* Define these anyway so we don't need as much ifdef'ed code. */
        char *encoded_name = NULL;
        char *encoded_value = NULL;

        print_entry_location();

        lower_dentry = DENTRY_TO_LOWER(dentry);

        BUG_ON(!lower_dentry);
        BUG_ON(!lower_dentry->d_inode);
        BUG_ON(!lower_dentry->d_inode->i_op);

        fist_dprint(18, "getxattr: name=\"%s\", value %d bytes\n", name, (int) size);

        if (lower_dentry->d_inode->i_op->getxattr) {
                encoded_name = (char *)name;

                encoded_value = (char *)value;


                lock_inode(lower_dentry->d_inode);
                /* lock_kernel() already done by caller. */
                err = lower_dentry->d_inode->i_op->getxattr(lower_dentry, encoded_name, encoded_value, size);
                /* unlock_kernel() will be done by caller. */
                unlock_inode(lower_dentry->d_inode);

        }

out:
        print_exit_status(err);
        return err;
}

/*
 * BKL held by caller.
 * dentry->d_inode->i_{sem,mutex} down
 */
STATIC int //XXX: was made consistent
monitorfs_setxattr(struct dentry *dentry, const char *name, const void *value,size_t size, int flags)

{
        struct dentry *lower_dentry = NULL;
        int err = -ENOTSUPP;
        /* Define these anyway, so we don't have as much ifdef'ed code. */
        char *encoded_value = NULL;
        char *encoded_name = NULL;

        print_entry_location();

        lower_dentry = DENTRY_TO_LOWER(dentry);

        BUG_ON(!lower_dentry);
        BUG_ON(!lower_dentry->d_inode);
        BUG_ON(!lower_dentry->d_inode->i_op);

        fist_dprint(18, "setxattr: name=\"%s\", value %d bytes, flags=%x\n", name, (int) size, flags);

        if (lower_dentry->d_inode->i_op->setxattr) {
                encoded_name = (char *)name;

                encoded_value = (char *)value;

                lock_inode(lower_dentry->d_inode);
                /* lock_kernel() already done by caller. */
                err = lower_dentry->d_inode->i_op->setxattr(lower_dentry, encoded_name, encoded_value, size, flags);
                /* unlock_kernel() will be done by caller. */
                unlock_inode(lower_dentry->d_inode);
        }

out:
        print_exit_status(err);
        return err;
}

/*
 * BKL held by caller.
 * dentry->d_inode->i_{sem,mutex} down
 */
STATIC int
monitorfs_removexattr(struct dentry *dentry, const char *name)
{
        struct dentry *lower_dentry = NULL;
        int err = -ENOTSUPP;
        char *encoded_name;
        print_entry_location();

        lower_dentry = DENTRY_TO_LOWER(dentry);

        BUG_ON(!lower_dentry);
        BUG_ON(!lower_dentry->d_inode);
        BUG_ON(!lower_dentry->d_inode->i_op);

        fist_dprint(18, "removexattr: name=\"%s\"\n", name);

        if (lower_dentry->d_inode->i_op->removexattr) {
                encoded_name = (char *)name;

                lock_inode(lower_dentry->d_inode);
                /* lock_kernel() already done by caller. */
                err = lower_dentry->d_inode->i_op->removexattr(lower_dentry, encoded_name);
                /* unlock_kernel() will be done by caller. */
                unlock_inode(lower_dentry->d_inode);
        }

out:
        print_exit_status(err);
        return err;
}

/*
 * BKL held by caller.
 * dentry->d_inode->i_{sem,mutex} down
 */
STATIC ssize_t
monitorfs_listxattr(struct dentry *dentry, char *list, size_t size)
{
        struct dentry *lower_dentry = NULL;
        int err = -ENOTSUPP;
        char *encoded_list = NULL;

        print_entry_location();

        lower_dentry = DENTRY_TO_LOWER(dentry);

        BUG_ON(!lower_dentry);
        BUG_ON(!lower_dentry->d_inode);
        BUG_ON(!lower_dentry->d_inode->i_op);

        if (lower_dentry->d_inode->i_op->listxattr) {
                encoded_list = list;
                lock_inode(lower_dentry->d_inode);
                /* lock_kernel() already done by caller. */
                err = lower_dentry->d_inode->i_op->listxattr(lower_dentry, encoded_list, size);
                /* unlock_kernel() will be done by caller. */
                unlock_inode(lower_dentry->d_inode);
        }

out:
        print_exit_status(err);
        return err;
}

struct inode_operations monitorfs_symlink_iops =
{
        readlink:   monitorfs_readlink,
        follow_link: monitorfs_follow_link,
	put_link: monitorfs_put_link,
        permission: monitorfs_permission,
        //revalidate: monitorfs_inode_revalidate,
        setattr:    monitorfs_setattr,
#if 0
        // XXX: off, b/c the VFS doesn't call getattr yet
        getattr:    monitorfs_getattr,
#endif

        setxattr:   monitorfs_setxattr,
        getxattr:   monitorfs_getxattr,
        listxattr:  monitorfs_listxattr,
        removexattr: monitorfs_removexattr
};

struct inode_operations monitorfs_dir_iops =
{
        create: monitorfs_create,
        lookup: monitorfs_lookup,
        link:   monitorfs_link,
        unlink: monitorfs_unlink,
        symlink:    monitorfs_symlink,
        mkdir:  monitorfs_mkdir,
        rmdir:  monitorfs_rmdir,
        mknod:  monitorfs_mknod,
        rename: monitorfs_rename,
        /* no readlink/follow_link for non-symlinks */
        // off because we have setattr
        //    truncate:	monitorfs_truncate,
        permission: monitorfs_permission,
        //revalidate: monitorfs_inode_revalidate,
        setattr:    monitorfs_setattr,
#if 0
        // XXX: off, b/c the VFS doesn't call getattr yet
        getattr:    monitorfs_getattr,
#endif
        setxattr:   monitorfs_setxattr,
        getxattr:   monitorfs_getxattr,
        listxattr:  monitorfs_listxattr,
        removexattr: monitorfs_removexattr
};

struct inode_operations monitorfs_main_iops =
{
        permission: monitorfs_permission,
        //revalidate: monitorfs_inode_revalidate, //XXX: Revalidate is GONE
        setattr:    monitorfs_setattr,
#if 0
        // XXX: off, b/c the VFS doesn't call getattr yet
        getattr:    monitorfs_getattr,
#endif
        setxattr:   monitorfs_setxattr,
        getxattr:   monitorfs_getxattr,
        listxattr:  monitorfs_listxattr,
        removexattr: monitorfs_removexattr
};

/*
 * Local variables:
 * c-basic-offset: 4
 * End:
 */
