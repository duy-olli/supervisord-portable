/*
 * Copyright (c) 1997-2007 Erez Zadok <ezk@cs.stonybrook.edu>
 * Copyright (c) 2001-2007 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from
 * ftp://ftp.filesystems.org/pub/fistgen/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 * File: fistgen/templates/Linux-2.6/main.c
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_monitorfs.h"
#endif /* FISTGEN */
#include "fist.h"
#include "monitorfs.h"

struct monitorfs_modified_op_t monitorfs_modified_op;

extern void monitorfs_read_inode(inode_t *inode);

/* Older versions of Linux provide a trivial iget() function.  Newer versions
 * have dropped that, so we have created our own with equivalent
 * functionality.  Since the primatives that it uses exist on the older
 * versions, we just use our version across the board.
 */

struct inode *monitorfs_iget(struct super_block *sb, unsigned long ino)
{
    struct inode *inode = iget_locked(sb, ino);
    if (inode && (inode->i_state & I_NEW)) {
        monitorfs_read_inode(inode);
        unlock_new_inode(inode);
    }
    return inode;
}

/* sb we pass is monitorfs's super_block */
int
monitorfs_interpose(struct dentry *lower_dentry, struct dentry *dentry, super_block_t *sb, int flag)
{
        inode_t *lower_inode;
        int err = 0;
	inode_t *inode;

	print_entry_location();

	lower_inode = lower_dentry->d_inode; /* CPW: moved after print_entry_location */

	BUG_ON(!lower_inode);
	BUG_ON(dentry->d_inode != NULL);

	/*
	 * We allocate our new inode below, by calling iget.
	 * iget will call our read_inode which will initialize some
	 * of the new inode's fields
	 */
	/* check that the lower file system didn't cross a mount point */
	if (lower_inode->i_sb != SUPERBLOCK_TO_LOWER(sb)) {
		err = -EXDEV;
		goto out;
	}
	inode = monitorfs_iget(sb, lower_inode->i_ino);

	if (!inode) {
		err = -EACCES;		/* should be impossible??? */
		goto out;
	}

	/*
	 * interpose the inode if not already interposed
	 * this is possible if the inode is being reused
	 * XXX: what happens if we get_empty_inode() but there's another already?
	 * for now, ASSERT() that this can't happen; fix later.
	 */
	if (INODE_TO_LOWER(inode) == NULL)
		INODE_TO_LOWER(inode) = igrab(lower_inode);

	/* Use different set of inode ops for symlinks & directories*/
	if (S_ISLNK(lower_inode->i_mode))
		inode->i_op = &monitorfs_symlink_iops;
	else if (S_ISDIR(lower_inode->i_mode))
		inode->i_op = &monitorfs_dir_iops;
	/* Use different set of file ops for directories */
	if (S_ISDIR(lower_inode->i_mode))
		inode->i_fop = &monitorfs_dir_fops;

	/* properly initialize special inodes */
	if (S_ISBLK(lower_inode->i_mode) || S_ISCHR(lower_inode->i_mode) ||
            S_ISFIFO(lower_inode->i_mode) || S_ISSOCK(lower_inode->i_mode)) {
		init_special_inode(inode, lower_inode->i_mode, lower_inode->i_rdev);
	}

	//inode->i_mapping->a_ops = &monitorfs_aops;
	/* Fix our inode's address operations to that of the lower inode */
	if (inode->i_mapping->a_ops != lower_inode->i_mapping->a_ops) {
		fist_dprint(7, "fixing inode 0x%p a_ops (0x%p -> 0x%p)\n",
                        inode, inode->i_mapping->a_ops,
                        lower_inode->i_mapping->a_ops);
		inode->i_mapping->a_ops = lower_inode->i_mapping->a_ops;
	}

	/* only (our) lookup wants to do a d_add */
	if (flag)
		d_add(dentry, inode);
	else
		d_instantiate(dentry, inode);

	BUG_ON(!DENTRY_TO_PRIVATE(dentry));

	/* all well, copy inode attributes */
	fist_copy_attr_all(inode, lower_inode);

out:
	print_exit_status(err);
	return err;
}


/* find lower dentry given this monitorfs dentry */
struct dentry *
__monitorfs_lower_dentry(const char *file, const char *func, int line, struct dentry *dentry)
{
	struct dentry *lower_dentry;

	BUG_ON(!dentry);
	BUG_ON(!dentry->d_op);
        BUG_ON(dentry->d_op != &monitorfs_dops);

	BUG_ON(dentry->d_sb->s_op != &monitorfs_sops);
        if (dentry->d_inode) {
                BUG_ON(dentry->d_inode->i_op != &monitorfs_main_iops &&
                       dentry->d_inode->i_op != &monitorfs_dir_iops &&
                       dentry->d_inode->i_op != &monitorfs_symlink_iops);
        }
	lower_dentry = DENTRY_TO_LOWER(dentry);
	BUG_ON(!lower_dentry);
	return lower_dentry;
}


/*
 * Parse mount options: dir=XXX and debug=N
 *
 * Returns the dentry object of the lower-level (lower) directory;
 * We want to mount our stackable file system on top of that lower directory.
 *
 * Sets default debugging level to N, if any.
 */
int monitorfs_parse_options(super_block_t *sb, char *options, struct dentry **lower_root, struct vfsmount **lower_mount)
{
	struct nameidata nd;
	char *name, *tmp, *end;
	int err = 0;
	int dir_specified = 0;

	print_entry_location();

	/* We don't want to go off the end of our arguments later on. */
	for (end = options; *end; end++);

	while (options < end) {
		tmp = options;
		while (*tmp && *tmp != ',')
			tmp++;
		*tmp = '\0';
		if (!strncmp("dir=", options, 4)) {
			/* note: the name passed need not be encoded */
			name = options + 4;
			fist_dprint(4, "monitorfs: using directory: %s\n", name);
			err = path_lookup(name, LOOKUP_FOLLOW, &nd);
			if (err) {
				printk("monitorfs: error accessing lower directory '%s'\n", name);
				goto out;
			}
			*lower_root = NAMEIDATA_TO_DENTRY(&nd);
			*lower_mount = NAMEIDATA_TO_VFSMNT(&nd);
			fist_dprint(6, "parse_options: new s_root, inode: %p, %p\n",
                                    *lower_root, (*lower_root)->d_inode);
			dir_specified = 1;
		}
		else if (!strncmp("debug=", options, 6)) {
			int debug = simple_strtoul(options + 6, NULL, 0);
			fist_set_debug_value(debug);
		} else {
			printk(KERN_WARNING "monitorfs: unrecognized option '%s'\n", options);
		}
		options = tmp + 1;
	}
	if (dir_specified != 1) {
		err = -EINVAL; /* dir option must be specified */
		printk("Please specify dir option\n");
	}

out:
	print_exit_location();
	return err;
}

#ifdef FIST_MALLOC_DEBUG
/* for malloc debugging */
static atomic_t monitorfs_malloc_counter;

void *
monitorfs_kmalloc(size_t len, int flag, int line, const char *file)
{
	void *ptr = (void *) kmalloc(len, flag);
	if (ptr) {
		atomic_inc(&monitorfs_malloc_counter);
		printk("KM:%d:%p:%d:%s\n", 
                        (int) atomic_read(&monitorfs_malloc_counter),
                        ptr, line, file);
	}
	return ptr;
}

void
monitorfs_kfree(void *ptr, int line, const char *file)
{
	atomic_inc(&monitorfs_malloc_counter);
	printk("KF:%d:%p:%d:%s\n", 
                (int) atomic_read(&monitorfs_malloc_counter), ptr, line, file);
	kfree(ptr);
}
#endif /* FIST_MALLOC_DEBUG */




/* for attach mode, we use a different ->read_super() in attach.c */
static int
monitorfs_read_super(super_block_t *sb, void *raw_data, int silent)
{
	struct dentry *lower_root = NULL;
	struct vfsmount *lower_mount = NULL;
	int err = 0;

	print_entry_location();

#ifdef FIST_MALLOC_DEBUG
	atomic_set(&monitorfs_malloc_counter, 0); /* for malloc debugging */
#endif /* FIST_MALLOC_DEBUG */

	if (!raw_data) {
		printk(KERN_WARNING "monitorfs_read_super: missing data argument\n");
		err = -EINVAL;
		goto out_no_raw;
	}
	/*
	 * Allocate superblock private data
	 */
	SUPERBLOCK_TO_PRIVATE_SM(sb) = KMALLOC(sizeof(struct monitorfs_sb_info), GFP_KERNEL);
	if (!SUPERBLOCK_TO_PRIVATE(sb)) {
		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
		err = -ENOMEM;
		goto out;
	}
	memset(SUPERBLOCK_TO_PRIVATE(sb), 0, sizeof(struct monitorfs_sb_info));


	if ((err = monitorfs_parse_options(sb, raw_data, &lower_root, &lower_mount))) {
		goto out_free;
	}
	if (IS_ERR(lower_root)) {
		printk(KERN_WARNING "monitorfs_read_super: lookup_dentry failed (err = %ld)\n", PTR_ERR(lower_root));
		err = PTR_ERR(lower_root);
		goto out_free;
	}
	if (!lower_root->d_inode) {
		printk(KERN_WARNING "monitorfs_read_super: no directory to interpose on\n");
		goto out_dput;
	}
	SUPERBLOCK_TO_LOWER(sb) = lower_root->d_sb;

	sb->s_maxbytes = lower_root->d_sb->s_maxbytes;

	sb->s_op = &monitorfs_sops;
	/*
	 * we can't use d_alloc_root if we want to use
	 * our own interpose function unchanged,
	 * so we simply replicate *most* of the code in d_alloc_root here
	 */

	sb->s_root = d_alloc(NULL, &(const struct qstr){hash: 0, name: "/", len: 1});
        if (IS_ERR(sb->s_root)) {
		printk(KERN_WARNING "monitorfs_read_super: d_alloc failed\n");
		err = -ENOMEM;
		goto out_dput;
	}

	sb->s_root->d_op = &monitorfs_dops;
	sb->s_root->d_sb = sb;
	sb->s_root->d_parent = sb->s_root;
	/* link the upper and lower dentries */
	DENTRY_TO_PRIVATE_SM(sb->s_root) = (struct monitorfs_dentry_info *) KMALLOC(sizeof(struct monitorfs_dentry_info), GFP_KERNEL);

	if (!DENTRY_TO_PRIVATE(sb->s_root)) {
		err = -ENOMEM;
		goto out_dput2;
	}
	DENTRY_TO_LOWER(sb->s_root) = lower_root;
	DENTRY_TO_LVFSMNT(sb->s_root) = lower_mount;


	if ((err = monitorfs_interpose(lower_root, sb->s_root, sb, 0)) != 0)
		goto out_dput2;

	fist_print_dentry("monitorfs_read_super OUT lower_dentry", lower_root);
	fist_print_inode("monitorfs_read_super OUT lower_inode", lower_root->d_inode);
	// next line causes null ptr deref at mount(2) time
	// fist_print_dentry("%s OUT sb->s_root", __FUNCTION__, sb->s_root);
	goto out;

out_dput2:
	dput(sb->s_root);
out_dput:
	dput(lower_root);
out_free:
	// XXX: HL: is that mntput necessary? There is some relation to the path_walk in parse_options -
	//  there the path_release is "missing"
	mntput(lower_mount);
	KFREE(SUPERBLOCK_TO_PRIVATE(sb));
	SUPERBLOCK_TO_PRIVATE_SM(sb) = NULL;
out:
	fist_print_sb("OUT sb", sb);
	if (SUPERBLOCK_TO_PRIVATE(sb))
		fist_print_sb("OUT lower_sb", SUPERBLOCK_TO_LOWER(sb));
out_no_raw:
	print_exit_location();
	return err;
}



#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
static struct super_block *monitorfs_get_sb(struct file_system_type *fs_type,
                                         int flags, const char *dev_name,
                                         void *raw_data)
{

	return get_sb_nodev( fs_type, flags, raw_data, monitorfs_read_super );
}
#else
static int monitorfs_get_sb(struct file_system_type *fs_type,
                                         int flags, const char *dev_name,
                                         void *raw_data, struct vfsmount *mnt)
{

	return get_sb_nodev( fs_type, flags, raw_data, monitorfs_read_super, mnt );
}
#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) */

void monitorfs_kill_block_super(struct super_block *sb)
{
	generic_shutdown_super(sb);
/*
 *	XXX: BUG: Halcrow: Things get unstable sometime after this point:
 *
 *	lib/rwsem-spinlock.c:127: spin_is_locked on uninitialized
 *	spinlock a1c953d8.
 *
 *	fs/fs-writeback.c:402: spin_lock(fs/super.c:a0381828) already
 *	locked by fs/fs-writeback.c/402
 *
 *	Apparently, someone's not releasing a lock on sb_lock...
*/
}

static struct file_system_type monitorfs_fs_type = {
	.owner          = THIS_MODULE,
	.name           = "monitorfs",
	.get_sb         = monitorfs_get_sb,
	.kill_sb        = monitorfs_kill_block_super,
	.fs_flags       = 0,
};

static int __init init_monitorfs_fs(void)
{
        int err;
	printk("Registering monitorfs version $Id: main.c,v 1.33 2007/11/30 15:29:55 ezk Exp $\n");
        err = monitorfs_init_inodecache();
        if (err)
                goto out1;
				
	monitorfs_modified_op.buffer = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);
	if (!monitorfs_modified_op.buffer) {
			err = -ENOMEM;
			goto out2;		
	}
	memset(monitorfs_modified_op.buffer, 0, PAGE_CACHE_SIZE);
	monitorfs_modified_op.src_pathname = NULL;
	monitorfs_modified_op.dst_pathname = NULL;
	monitorfs_modified_op.pid = 0;
	monitorfs_modified_op.seqnum = 0;
	mutex_init(&monitorfs_modified_op.mod_op_mux);
	mutex_init(&monitorfs_modified_op.send_ack_mux);
	init_waitqueue_head(&monitorfs_modified_op.waitq);
  
	err = monitorfs_init_netlink();
	if (err) {
		printk(KERN_ERR "Failure occured while attempting to "
				"initialize the Monitorfs netlink socket\n");
		goto out3;
	}	
	
	err = register_filesystem(&monitorfs_fs_type);
	if (err)
		goto out4;
	
    return 0;
out4:
	monitorfs_release_netlink();
out3:
	kfree(monitorfs_modified_op.buffer);	
out2:
    monitorfs_destroy_inodecache();
out1:
    return err;
}
static void __exit exit_monitorfs_fs(void)
{
	printk("Unregistering monitorfs version $Id: main.c,v 1.33 2007/11/30 15:29:55 ezk Exp $\n");
	monitorfs_destroy_inodecache();
	kfree(monitorfs_modified_op.buffer);
	monitorfs_release_netlink();
	unregister_filesystem(&monitorfs_fs_type);
}

int reverse_lookup(struct dentry *dentry, char * buffer, int last_index)
{
	struct super_block *sb;
	
	if (last_index <= 0) {
		return 0;
	}
	
	sb = dentry->d_sb;
	buffer[last_index] = 0;
	while (dentry &&  *dentry->d_name.name != '/' && last_index - dentry->d_name.len - 1 > 0) {
		last_index -= dentry->d_name.len; 
		memcpy(buffer + last_index, dentry->d_name.name, dentry->d_name.len);
		last_index -= 1;
		buffer[last_index] = '/';
		dentry = dentry->d_parent;
	}
		
	if (last_index <= 0) {
		return 0;
	} else {
		return last_index;
	}
}

void monitorfs_log_operation(u8 operation, struct dentry *src_dentry, struct dentry *dst_dentry, struct file *file)
{
	char ops[5] = {'x', 'c', 'm', 'd', 'r'};
	int offset1, offset2;
	int last_index;
	int tlen;
	char *data;
	
	if (operation == MONITORFS_OPS_MODIFY && operation == monitorfs_modified_op.operation
			&& monitorfs_modified_op.file == file) {
		return;
	}
	
	mutex_lock(&monitorfs_modified_op.mod_op_mux);
	monitorfs_modified_op.operation = operation;
	monitorfs_modified_op.file = file;
	last_index = PAGE_CACHE_SIZE - 1;
	offset1 = reverse_lookup(src_dentry, monitorfs_modified_op.buffer, last_index);
	monitorfs_modified_op.src_pathname = &monitorfs_modified_op.buffer[offset1];
	
	if (operation == MONITORFS_OPS_RENAME) {
		last_index = offset1 - 1;
		offset2 = reverse_lookup(dst_dentry, monitorfs_modified_op.buffer, last_index);
		monitorfs_modified_op.dst_pathname = &monitorfs_modified_op.buffer[offset2];
		monitorfs_modified_op.buffer[last_index] = '|';
		data = monitorfs_modified_op.buffer + offset2 - 2;
	} else {
		data = monitorfs_modified_op.buffer + offset1 - 2;
	}
	
	if (data >= monitorfs_modified_op.buffer && monitorfs_modified_op.pid) {
		data[0] = ops[operation];
		data[1] = '|';
		//monitorfs_printk(KERN_WARNING, "%s\n", data);
		monitorfs_send_and_ack(data, strlen(data) + 1, monitorfs_modified_op.pid);
	}
	mutex_unlock(&monitorfs_modified_op.mod_op_mux);
}

MODULE_AUTHOR("Erez Zadok <ezk@cs.sunysb.edu>");
MODULE_DESCRIPTION("FiST-generated monitorfs filesystem");

/*
 * Note: you must define *some* non-empty license string in your .fist file,
 * using the "license" declaration.  It's up to the author to decide what
 * they want: it can be anything.  But if on Linux you pick something other
 * than the approved licenses as listed in <linux/module.h>, your module may
 * not link into the kernel if it's using GPL-only symbols.  For more
 * information, see the COPYING file which should be in the same directory
 * you found this file in.
 */
/* This definition must only appear after we include <linux/module.h> */
MODULE_LICENSE("GPL");	/* defined via "license" decl in .fist file */
#ifndef MODULE_LICENSE
# error must define module license via fistgen license declaration
#endif /* not MODULE_LICENSE */

module_param(fist_debug_var, int, 0644);
MODULE_PARM_DESC(fist_debug_var, "Debug level");

module_init(init_monitorfs_fs)
module_exit(exit_monitorfs_fs)

/*
 * Local variables:
 * c-basic-offset: 4
 * End:
 */
